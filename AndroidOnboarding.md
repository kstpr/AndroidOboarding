## Добре дошли в света на Андроид.

Андроид е система на 10 години. За които се събра доста джънк в платформата. През последните две години начинът по който пишем Андроид приложения се промени драстично. Респективно огромна част от информацията в интернет за това как да пишем приложения и какви API-та и компоненти да използваме за различните проблеми, ако не тотално грешна и неработеща, е в най-добрия случай нерелевантна и неоптимална. Смяната на парадигмата се случи толкова бързо, че дори официалната документация на места не е обновена. От друга страна някои от "официалните" гугълски компоненти, които идват с платформата са недобре приети от community-то (защото са тежки, тромави за работа, overengineer-нати или просто безумни) и има много third-party решения под формата на библиотеки и плъгини, които са дефакто стандарт.

Ще се опитам да ви on-board-na към основните неща и към доказано работещите концепции, които ние ползваме.

Основният и най-базов компонент в едно Андроид приложение е [Activity](https://developer.android.com/guide/components/activities/intro-activities). Най-грубо казано (и донякъде вече невярно) Activity-то представлява екран в приложението. Не го инициализирате саме, правите клас, който го наследява и овъррайдвате някакви методи, които са ви нужни, декларирате го в един xml (Manifest) и системата го създава вместо вас. В Activity-то инициализираме UI-я, обновяваме го и слушаме за промени. Activity-то за съжаление представлява и входна точка към цялата система (бидейки Context, което е един класически God-object). Искате да ползвате bluetooth-функционалност - трябва ви Activity. Искате да достъпите стрингове или други ресурси - пак през него. Което спомогна драстично, в исторически план, за оплитане на UI и бизнес логика. Понеже Activity-то се менажира от системата, а системата е асинхронна и по всяко време може да реши да минимизира вашето приложение (примерно при входящ разговор) или директно да го убие (при липса на памет) има т.нар **lifecycle callbacks** в които може да модифицирате поведението на приложението. Примерно когато отива в background-a може би искаме да спрем мрежовите конекции или поне да не обновяваме UI-я (понеже иначе крашва :X). И **най-големият pain-point** - когато си завъртите устройството UI-ят не се преоразмерява, а цялото Activity се унощожава и създава наново. За това да запазите състоянието на UI-я и всички други обекти които се ползват и след да го възстановите в новото Activity сте отговорни вие.

Преди гледната точка беше да се прави Activity за всеки екран. В момента набира сила (дори плахо подкрепена и от Google) концепцията да се ползва само едно Activity за цялото приложение и в него да се сменят вариации на View и контролер (Presenter/ViewModel) за всеки екран. Т.е. се подразбира някаква форма на MV-Whatever архитектура, в която Activity-то играе ролята на "main" функцията в класическите десктоп приложения и на bridge за достъп до системата и общо-взето на нищо друго. Ако Activity-то след като сте си направили приложението е 50 реда, вероятно нещата са наред, ако е 3000 имате огромен проблем. Затова цялата UI и бизнес логика се делегират на View и контролер (presenter/viewmodel...) обекти. За View (обекти, не widget-и) обикновено се използват [фрагменти] (https://developer.android.com/guide/components/fragments). Исторически мислихме за тях като за "подекрани". Примерно на таблет може да се показват два едновременно, докато на телефон - последователно един след друг. И те имат собствен lifecycle, свързан с този на host Activity-то, но по-различен, от което произтичат известни проблеми. Но са удобни и ги ползваме.

За "background" работа се използваха [Services](https://developer.android.com/guide/components/services), като под "background" работа разбираме не пускането на задача от рода на мрежова заявка на някаква нишка, а по-скоро каквото би правил примерно един музикален плеър докато UI-ят му е скрит. Те просто са компоненти без UI. От API 26 нагоре има рестрикции за такива сървиси и полезността им вече е ограничена.

UI-ят се декларира в xml. Може да се нагласи и през кода, но никой не го прави. Има и визуални инструменти за редене на UI, но са малко бъгави и главно си го пишем на ръка. За декларирането на UI може да прочетете [тук]( https://developer.android.com/guide/topics/ui/declaring-layout). Напоследък е модерен [ConstraintLayout-a](https://developer.android.com/training/constraint-layout/), главният плюс на който е, че нещата там са релативни и базирани на пропорции и връзки между вю-тата и не трябва да се правят 10 различни layout-a за всеки възможен размер екрани. Минус е, че се учи по-трудно и визуалният едитор често предизвиква бърстове от псувни. Но предимствата са повече от недостатъците.

За показване на списъци се използва [RecyclerView ](https://developer.android.com/guide/topics/ui/layout/recyclerview). То е високоефективно и преизползва UI-клетките които се показват в списъка. Това води до известна комплексност, която не се очакава от един тъп списък. Но я има.

[Файлове](https://developer.android.com/guide/topics/data/). Няма голяма драма там.

Camera API-то ще ви донесе само болка. Може би е най-безумното и фундаментално сбъркано API в целия Андроид. Всеки компонент, който го ползва неминуемо става на Big Ball of Mud. Има Camera2, което уж е малко по-културно. Напоследък стана популярна библиотеката [CameraKit](https://github.com/CameraKit/camerakit-android), като не-шизофренична алтернатива на платформетното API.

За http и REST заявки ползваме [Retrofit](https://square.github.io/retrofit/) и [OkHttp](https://square.github.io/okhttp/). Всичко друго е пълно безумие. Особено вградената в Android библиотека Volley. Retrofit вътрешно ползва OkHttp. Ретрофит автоматично десериализира JSON-ите (или протобуферите), които идват в респонсите до обекти. Има голям избор от библиотеки, които осъществяват десериализацията. Ние ползваме RxAdapterFactory за директна интеграция с RxJava - заявките автоматично се превръщат в асинхронни observable-и. Иначе работи с класически callbacks, основният минус на които е композирането (callback hell).

За работа с бази данни има няколко варианта. Класически, директно се ползваше SQLite база данни (SQLite се ползва по подразбиране в Андроид) и нещо наречено SqliteOpenHelper, в което заявките се правеха ръчно и се премятаха курсори и пр. ужаси. В момента на това се гледа с лошо око и стандартът в платформата е библиотеката [Room](https://developer.android.com/topic/libraries/architecture/room). Много прилича на Retrofit. DAO/Entitiy-базирана е. Заявките се сглабят през анотации и се проверяват по време на компилация, така че има допълнително ниво на сигурност.
Друг вариант е да се ползва ORM, съществуват доста варианти, както и разни други библиотеки от рода на [SQLDelight](https://github.com/square/sqldelight/) - генерира модели от sql-a и [SQLBrite](https://github.com/square/sqlbrite) - реактивен wrapper над базата.
Последен вариант е [Realm](https://realm.io), който също е много широко използван. Представлява object store.

[Dagger2](https://github.com/google/dagger) е dependency injection framework-a, който е най-популярен в Андроид. Има големи позитиви от негом но се учи трудно и бавно и прави кода напълно неразбираем за хора, незапознати с Dagger. Първоначално може и без него, просто правете manual DI - подавайте dependency-тата през конструктора, вместо да ги инициализирате в класовете.

[Glide](https://github.com/bumptech/glide)/[Picasso](https://square.github.io/picasso/)    са двете алтернативи за зареждане на тъмбнейли (нещо което не искате да правите ръчно!). Имат почти еднакви API-та, като разликите във функционалността не са драстични и за всеки проект трябва да се решава на индивидуално ниво коя библиотека да се ползва.

И стигаме до другата най-болезнена точка - асинхронната работа. Блокирането на UI-нишката е напълно забранено, ако я блокирате за 5 секунди преди се показваше един диалог _Application Not Responding [Wait/Close]_. Именно този, да, на който много пъти сте избирали _Close_. Това беше досега, от последната версия на Андроид апп-овете вече директно биват убивани без предупреждение.
Т.е. всички тежки операции от рода на CRUD, мрежови заявки, изчисления, преоразмеряване на битмапи, сейване и зареждане на файлове от файловата система, machine learning... - трябва да се правят на бекграунд нишки. Което директно ги превръща в асинхронни операции. Един вариант е да ги пишем ръчно, но това е глупаво, много бойлерплейт за нищо, а е и опасно. Затова в Андроид съществуваше примитив, който вътрешно менажира нишка за бекграунд работа, наречен _AsyncTask_. Старите приложения и туториалите в интернет са пълни с такива. За съжаление AsyncTask-овете са доста тъпо решение, което в много случаи носи повече негативи отколкото ползи. Двете разумни решения на проблема са [RxJava](https://http://reactivex.io/) за Java и Kotlin и [корутини](https://kotlinlang.org/docs/reference/coroutines.html) (само Kotlin). Минус на RxJava е, че се учи много трудно, понеже представлява изцяло нова парадигма, всичко останало е плюс. RxJava е дефакто стандарт, но решението дали да се ползва трябва да се вземе на ниво тийм, ако има хора които не я знаят/разбират/не могат да я разберат може да донесе повече негативи. Макар че като гледам реакциите на community-то е несериозно да не се знае в дългосрочен план.
Настоящата версия е RxJava 2. Търсене в youtube и medium ще намери купища туториали.

Юнит тестовете са супер важни, използват се JUnit 4 и 5 и PowerMock. Robolectric също се използва за мокване, но по-добре PowerMock, където е възможно. За някои тестове, които зависят от системни компоненти, примерно база данни, трябва истинско устройство или емулатор с истинска база. Което малко усложнява нещата. Също се ползват и функционални и end-to-end автоматизирани тестове с Espresso, които се рънват на емулатор или истинско устройство.

## Putting it all together.

Както споменах по-рано в Андроид няма архитектура по подразбиране, енфорсната от Google, затова се наложи community-то само да си измисли. И имаше период, в който измисляше с кофата. Изкристализиралият резултат може да видите [тук]( https://github.com/googlesamples/android_architecture). Най-популярни като че ли са MVP и донякъде MVVM. MVI е супер, но трябва Rx + функционално мислене. Също така от Google отново не заеха силна позиция за това каква архитектура да се ползва, а предложиха серия от building blocks, които може да се ползват в различни архитектури - т.нар. **Architecture Components**, част от т.нар "чисто нов" [Jetpack](https://developer.android.com/jetpack/). Идеята на JetPack-a е да представлява най-оптималните, според Google, API-та (щото има по 15 API-та, които правят едно и също по различен начин...) и добри практики, които хората да ползват. Полезни изглеждат ViewModel, Room, Navigation библиотеката, WorkManager и донякъде LifeCycle компонентите. 